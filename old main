from keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img
from matplotlib import pyplot as plt
import numpy as np
from skimage import io
from skimage.util import img_as_float
import pandas as pd

# from scipy.ndimage.filters import gaussian_filter


patch_dim = 31
total_patches = 4800
positive_proprtion = 0.8
patches_per_image = None
num_training_images = None
current_img_index = -1
patches_per_image = 0
df = None


def main():
    global patches_per_image, num_training_images
        #number of training data
        # num_training_images = len(train)
        num_training_images = 40
        df = pd.DataFrame(index=np.arange(total_patches), columns=np.arange(patch_dim ** 2 * 3 + 1))
        patches_per_image = total_patches / num_training_images

        img_array = io.imread('/Users/filip.blaszczyk/PycharmProjects/eyeball-vessels-recognition/datasets/raw/1/raw (1).JPG')

        plt.imshow(img_array / 255., interpolation='none')
        # blurred = gaussian_filter(img_array, sigma=7)

        plt.imshow(blurred / 255., interpolation=None)

        # get_random_patches(img_array, img_array)

        # plt.show()


def load_next_img(paths, mask_data, gt_data):
    global current_img_index, current_img, current_mask, current_gt

    if current_img_index < len(paths) - 1:
        current_img_index += 1
        print("Working on image %d" % (current_img_index + 1))
        current_img = io.imread(paths[current_img_index])
        current_mask = img_as_float(io.imread(mask_data[current_img_index]))
        current_gt = img_as_float(io.imread(gt_data[current_img_index]))
        return True
    else:
        print('No more images left in set')
        return False


def get_random_patches(gt_array, mask_array):
    pos_count = 0
    neg_count = 0

    while pos_count + neg_count < patches_per_image:
        i = np.random.randint(patch_dim / 2, gt_array.shape[0] - patch_dim / 2)
        j = np.random.randint(patch_dim / 2, gt_array.shape[1] - patch_dim / 2)
        h = (patch_dim - 1) / 2

        if int(np.sum(mask_array[i - h:i + h + 1, j - h:j + h + 1]) / patch_dim ** 2) == 1:
            ind = current_img_index * patches_per_image + pos_count + neg_count

            # If a positive sample is found and positive count hasn't reached its limit
            if int(gt_array[i, j]) == 1 and pos_count < positive_proprtion * patches_per_image:
                df.loc[ind][0:-1] = np.reshape(mask_array[i - h:i + h + 1, j - h:j + h + 1], -1)
                df.loc[ind][patch_dim ** 2 * 3] = int(gt_array[i, j])
                pos_count += 1
            # If a negative sample is found and negative count hasn't reached its limit
            elif int(gt_array[i, j]) == 0 and neg_count < (1 - positive_proprtion) * patches_per_image:
                df.loc[ind][0:-1] = np.reshape(mask_array[i - h:i + h + 1, j - h:j + h + 1], -1)
                df.loc[ind][patch_dim ** 2 * 3] = int(gt_array[i, j])
                neg_count += 1

    print(i, j, h)


if __name__ == "__main__":
    main()
